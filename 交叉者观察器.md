## 交叉观察器 - IntersectionObserver

#### 1. Usage<br />
`const io = new IntersectionObserver(callback, option)` <br/>

IntersectionObserver 是浏览器原生提供的构造函数，接受两个参数：
-  callback：可见性发现变化时的回调函数
-  option：配置对象（可选）。

构造函数的返回值是一个观察器实例。实例一共有4个方法：
-  observe：开始监听特定元素
-  unobserve：停止监听特定元素
-  disconnect：关闭监听工作
-  takeRecords：返回所有观察目标的对象数组
#### 2. callback参数
-  标元素的可见性变化时，会调用观察器的回调函数callback
-  一般会触发两次，一次是目标元素刚刚进入视口时，另一次是目标元素完全离开视口
```
const io = new IntersectionObserver((changes, observer) => {})
```
-  callback函数接收两个参数：changes被观察对象数组，observer返回实例中传入的option参数
#### 3. IntersectionObserverEntry 对象
-  上面的changes数组中的每一项都是一个IntersectionObserverEntry(io)对象
#### 4. 方法<br />
-  observe
  *  接收一个target参数，值是Element类型，用来指定被监听的目标元素
  *  如果需要观察多个节点，需要多次调用该方法
```
// 获取元素
const target = document.getElementById("dom");
// 开始观察
io.observe(target);
```
-  unobserve
  接收一个target参数，值是Element类型，用来指定被监听的目标元素
```
// 停止观察
io.unobserve(target);
```
-  disconnect
```
// 关闭观察器
io.disconnect();
```
-  takeRecords
  返回所有被观察的对象，返回值是一个数组
```
// 获取被观察元素
const observeList = io.takeRecords();
```
#### 5. 应用<br />
-  预加载（滚动加载、翻页加载、无限加载）
-  懒加载（后加载、惰性加载）等

**注意：**API 是异步的，不随着目标元素的滚动同步触发。
  

